//
//  main.c
//  PipeSpin
//
//  Created by Dave on 15/04/2021.
//

// libgba headers
#include <gba.h>
#include <pcx.h>

// c headers

// local headers
#include "hiscores.h"
#include "game.h"
#include "grid.h"
#include "video.h"
#include "random.h"
#include "config.h"
#include "colour.h"
#include "sound.h"

// mgba debug header
// bool mgba_open(void);
// void mgba_close(void);
// void mgba_printf(int level, const char* string, ...); - MGBA_LOG_FATAL MGBA_LOG_ERROR MGBA_LOG_WARN MGBA_LOG_INFO MGBA_LOG_DEBUG
// bool mgba_console_open(void);

#ifdef DEBUGGERY
#include "mgba.h"
#endif

//---------------------------------------------------------------------------------
// header for binary data generated by bin2o macro in makefile
//---------------------------------------------------------------------------------
#include "Ruby_pcx.h"
#include "soundbank.h"

#define 	REG_WAITCNT   *(vu16*)(REG_BASE+0x0204)

//---------------------------------------------------------------------------------
// storage space for palette data
//---------------------------------------------------------------------------------
u16 PaletteBuffer[256];

// globals
const u8 versionString[] = "V1.0";
bool pressed, aPressedTitle, startPressedTitle, seeded = false;
mm_sfxhand soundHandle;

const int btTiles[] = { 1, 2, 3, 3, 18, 33, 48, 3 };
int spinCount[5] = {0, 0, 0, 0, 0}, spinWait = 0, spinStep[5] = {1, 1, 1, 1, 1}, spinChar = 0;
const int spinFactor[5]= {4, 4, 4, 4, 4};

//---------------------------------------------------------------------------------
void gbaJamScreen ()
//---------------------------------------------------------------------------------
{
    jamScreen = true;

    SetMode(MODE_1);
    copyJam();
    BGCTRL[1] = (BG_PRIORITY(floorPrio) | CHAR_BASE(0) | BG_MOSAIC | BG_256_COLOR | SCREEN_BASE(31) | TEXTBG_SIZE_512x256);
    BGCTRL[2] = (BG_PRIORITY(gridPrio) | CHAR_BASE(3) | BG_256_COLOR | SCREEN_BASE(22) | ROTBG_SIZE_256x256);

    logoScale = 1 << 2;
    bgAS = (BGAffineSource){
            .x = (s32) 120 << 8, .y = (s32) 80 << 8, //Original data's center (8bit fp)
            .tX = (s16) 120, .tY = (s16) 80, //Display's center (not fp)
            .sX = (s16) logoScale, .sY = (s16) logoScale, //Scaling ratio (8bit fp)
            .theta = 1    //Angle of rotation (8bit fp) Effective Range 0-FFFF
    };
    VBlankIntrWait();
    SetMode(MODE_1 | BG1_ON | BG2_ON | OBJ_1D_MAP | OBJ_ON);
    disableAllSprites();
    //FadeToPalette(cloudsPal, 60);

    aPressedTitle = startPressedTitle = false;
    soundHandle = mmEffect(SFX_GBAPING);
    int jamTime = 0;
    while (true) {
        VBlankIntrWait();
        jamTime++;

        keysPressed = keysDown();
        keysReleased = keysUp();
        keysHolded = keysHeld();
        if ((keysPressed & KEY_A) && (jamTime > (5 * 60))) {
            aPressedTitle = true;
        } else if (((keysPressed & KEY_START) && (jamTime > (5 * 60))) || ((keysHolded & KEY_START) && (keysHolded & KEY_SELECT))) {
            startPressedTitle = true;
        }
        if (((keysReleased & KEY_A) && aPressedTitle) || ((keysReleased & KEY_START) && startPressedTitle)) {
            aPressedTitle = startPressedTitle = false;
            jamFade = true;
            FadeToBlack(30);
            break;
        }
    }
    mmEffectCancel(soundHandle);
    jamScreen = false;
    REG_DMA3CNT = 0;
    REG_BG1HOFS = 0;
    disableAllSprites();
    bgAS = (BGAffineSource){
            .x = (s32) 120 << 8, .y = (s32) 80 << 8, //Original data's center (8bit fp)
            .tX = (s16) 120, .tY = (s16) 80, //Display's center (not fp)
            .sX = (s16) 1 << 8, .sY = (s16) 1 << 8, //Scaling ratio (8bit fp)
            .theta = 0    //Angle of rotation (8bit fp) Effective Range 0-FFFF
    };
    BgAffineSet(&bgAS, (BGAffineDest*)&REG_BG2PA, (s32) 1);
}//void gbaJamScreen

//---------------------------------------------------------------------------------
void imoRubyScreen ()
//---------------------------------------------------------------------------------
{
    SetMode(MODE_4 | BG2_ON| OBJ_1D_MAP | OBJ_ON);        // screen mode & background to display

    DecodePCX(Ruby_pcx, (u16*)VRAM , PaletteBuffer);

    CpuFastSet(pipesPal, (u16*)SPRITE_PALETTE, (pipesPalLen >> 2) | COPY32);
    FadeToPalette(PaletteBuffer, 20);
    CpuFastSet(pipesPal, (u16*)SPRITE_PALETTE, (pipesPalLen >> 2) | COPY32);

    aPressedTitle = startPressedTitle = false;

    int imoRTime = 0;
    while (true) {
        VBlankIntrWait();
        imoRTime++;

        keysPressed = keysDown();
        keysReleased = keysUp();
        if ((keysPressed & KEY_A) && (imoRTime > (1 * 60))) {
            aPressedTitle = true;
        } else if ((keysPressed & KEY_START) && (imoRTime > (1 * 60))) {
            startPressedTitle = true;
        }
        if (((keysReleased & KEY_A) && aPressedTitle) || ((keysReleased & KEY_START) && startPressedTitle)) {
            aPressedTitle = startPressedTitle = false;
            FadeToBlack(20);
            break;
        }
    }
}//void imoRubyScreen

//---------------------------------------------------------------------------------
void btScreen ()
//---------------------------------------------------------------------------------
{
    BGCTRL[2] = (BG_PRIORITY(2) | SCREEN_BASE(31));
    SetMode(MODE_0);
    //disableAllSprites();
    copyBittwyst();


    //fill background with black tile
    u32 x, y;
    for (y = 0; y < 16; y++) {
        for (x = 0; x < 16; x++) {
            doubleTileBT(x, y, 0, 31);
        }
    }

    for (int l = 0; l < 8; l++) {
        doubleTileBT(logoX + l, logoY, btTiles[l], 31);
    }

    // set screen H and V scroll positions
    bgOffsetX = 8; bgOffsetY = 8;
    BG_OFFSET[2].x = bgOffsetX;
    BG_OFFSET[2].y = bgOffsetY;

    SetMode(MODE_0 | BG2_ON| OBJ_1D_MAP | OBJ_ON);

    aPressedTitle = startPressedTitle = false;
    spinWait = btPause;

    int btTime = 0;
    while (true) {
        VBlankIntrWait();
        btTime++;

        if (spinWait == 0) {
            for (spinChar = 0; spinChar < 5; spinChar++) {
                spinCount[spinChar] += (spinStep[spinChar] * spinFactor[spinChar]);
                if (spinCount[spinChar] == 0) {
                    spinStep[spinChar] = 1;
                    if (spinChar == 0) spinWait = btPause;
                } else if (spinCount[spinChar] == (btTCount << btMult) - (1 << btMult)) {
                    spinStep[spinChar] = -1;
                }
                doubleTileBT(logoX + 3 + spinChar, logoY, btTiles[spinChar + 3] + (spinCount[spinChar] >> btMult), 31);
            }
        } else {
            spinWait--;
        }

        keysPressed = keysDown();
        keysReleased = keysUp();
        keysHolded = keysHeld();
        if ((keysPressed & KEY_A) && (btTime > (3 * 60))) {
                aPressedTitle = true;
        } else if (((keysPressed & KEY_START) && (btTime > (3 * 60))) || ((keysHolded & KEY_START) && (keysHolded & KEY_SELECT))) {
                startPressedTitle = true;
        }
        if (((keysReleased & KEY_A) && aPressedTitle) || ((keysReleased & KEY_START) && startPressedTitle)) {
            aPressedTitle = startPressedTitle = false;
            FadeToBlack(20);
            break;
        }
    }
}//void btScreen

//---------------------------------------------------------------------------------
void titleScreen ()
//---------------------------------------------------------------------------------
{
    inTitleScreen = true;

    SetMode(MODE_1);
    copyTitle();
    BGCTRL[0] = (BG_PRIORITY(floorPrio) | CHAR_BASE(pipeCharBlock) | BG_256_COLOR | SCREEN_BASE(bgMap) | TEXTBG_SIZE_256x256); //pipes
    BGCTRL[1] = (BG_PRIORITY(frontPrio) | CHAR_BASE(pipeCharBlock) | BG_16_COLOR | SCREEN_BASE(floorMap) | TEXTBG_SIZE_256x256); //menu
    BGCTRL[2] = (BG_PRIORITY(gridPrio) | CHAR_BASE(floorCharBlock) | BG_256_COLOR | SCREEN_BASE(gameUIMap) | ROTBG_SIZE_128x128); //"Spin"
    BG_OFFSET[1].x = 0;
    BG_OFFSET[1].y = 0;
    clearMenu(0, 0, 32, 32);

    REG_WININ = (0b000000 << 8) | (0b000010); //win1 () | win0 (BG1)
    REG_WINOUT = (0b000000 << 8) | (0b110101); //winObj () | winOut (Bld Obj BG2 BG0)

    REG_BLDCNT = (0b100000 << 8) | (0b11 << 6) | (0b000001); //BOT (BD) | fade to black | TOP (BG0)
    REG_BLDY = 0b10000; //blend weight - start at 16, fade to 8
    blendCount = 16;
    blendTimer = 0;

    bgAS = (BGAffineSource){
            .x = (s32) 37 << 8, .y = (s32) 22 << 8, //Original data's center (8bit fp)
            .tX = (s16) 163, .tY = (s16) 85, //Display's center (not fp)
            .sX = (s16) 1 << 8, .sY = (s16) 1 << 8, //Scaling ratio (8bit fp)
            .theta = 0    //Angle of rotation (8bit fp) Effective Range 0-FFFF
    };

    r256init(newSeed);
    for (int y = 0; y < 10; y++) {
        for (int x = 0; x < 15; x++) {
            doubleTileReg(x, y, ranRange(1, 28), pipeTileOffset, bgMap, 32); //random tile bg
        }
    }
    disableAllSprites();
    setSprite(1, 39, 62, 60, -255, gridPrio, false, false, 3); //"Pipe"
    setSprite(2, 39 + 64, 62, 60 + 32, -255, gridPrio, false, false, 3);

    VBlankIntrWait();
    SetMode(MODE_1 | BG0_ON | BG1_ON | BG2_ON | OBJ_1D_MAP | OBJ_ON);
    setPalettes ();

    printText (26, 19, (u8*) &versionString, 15);

    aPressedTitle = startPressedTitle = false;
    mmSetModuleTempo(1024);//standard speed
    if (!mmActive()) mmStart(MOD_TITLE, MM_PLAY_LOOP);
    titleTimer = 0;
    titleRotate = true;
    int titleTime = 0;
    while (true) {
        VBlankIntrWait();
        titleTime++;

        keysPressed = keysDown();
        keysReleased = keysUp();
        keysHolded = keysHeld();
        if ((keysPressed & KEY_A) && (titleTime > (1 * 60))) {
            aPressedTitle = true;
        } else if ((keysPressed & KEY_START) && (titleTime > (1 * 60))) {
            startPressedTitle = true;
        }
        if (((keysReleased & KEY_A) && aPressedTitle) || ((keysReleased & KEY_START) && startPressedTitle)) {
            aPressedTitle = startPressedTitle = false;
            bool repeatMenu = true;
            while (repeatMenu) {
                switch (doMenu(mStart, true, true, false)) {
                    case 0:
                        SetMode(MODE_1 | BG0_ON | BG1_ON | BG2_ON | OBJ_1D_MAP | OBJ_ON);
                        repeatMenu = false;
                        playSound(ascend);
                        FadeToBlack(60);
                        inTitleScreen = false;
                        break;
                    case 1:
                        SetMode(MODE_1 | BG0_ON | BG1_ON | BG2_ON | OBJ_1D_MAP | OBJ_ON);
                        doMenu(mSettings, false, false, false);
                        repeatMenu = true;
                        break;
                    default:
                        SetMode(MODE_1 | BG0_ON | BG1_ON | BG2_ON | OBJ_1D_MAP | OBJ_ON);
                        repeatMenu = false;
                        break;
                }
            }
            if (!inTitleScreen) break;
        }
    }
    titleRotate = false;
    REG_DMA3CNT = 0;
    REG_BG1HOFS = 0;
    disableAllSprites();
    bgAS = (BGAffineSource){
            .x = (s32) 120 << 8, .y = (s32) 80 << 8, //Original data's center (8bit fp)
            .tX = (s16) 120, .tY = (s16) 80, //Display's center (not fp)
            .sX = (s16) 1 << 8, .sY = (s16) 1 << 8, //Scaling ratio (8bit fp)
            .theta = 0    //Angle of rotation (8bit fp) Effective Range 0-FFFF
    };
    BgAffineSet(&bgAS, (BGAffineDest*)&REG_BG2PA, (s32) 1);
}//void titleScreen

//---------------------------------------------------------------------------------
// Program entry point
//---------------------------------------------------------------------------------
int main(void) {
//---------------------------------------------------------------------------------

#ifdef DEBUGGERY
    mgba_open();
    mgba_printf(MGBA_LOG_INFO, "Starting main()");
#endif

    //REG_WAITCNT = 0x4317; //standard for commercial & flash carts, might break supercard

    saveTimer = 0;
    checkSave();

    // the vblank interrupt must be enabled for VBlankIntrWait() to work
    irqInit();
    startSoundMM();
    irqSet(IRQ_VBLANK, mmVBlank);
    mmSetVBlankHandler(VblankInterrupt);
    irqEnable(IRQ_VBLANK);
    setVolume();

    disableAllSprites();

    inGame = false;
    playing = false;

    setRepeat(15, 5);

    gbaJamScreen();
    imoRubyScreen();
    btScreen();

    /*
    if (!seeded) {
        r256init(newSeed);
        seeded = true;
    }
    */

    initMenu();
    titleScreen();
    startLevel = 0;
    gameEnded = false;
    while (true) {
        if (levelScoreScreen()) {
            r256init(newSeed);
            gameScreen();
        } else {
            titleScreen();
            startLevel = 0;
        }
    }
}


